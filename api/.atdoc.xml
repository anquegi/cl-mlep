<?xml version="1.0" encoding="UTF-8"?>
<documentation include-slot-definitions-p="yes" single-page-p="yes" index-title="cl-mlep API reference" css="index.css" heading="cl-mlep API reference"><package name="mlep" id="mlep"><documentation-string><code>mlep</code> is a Machine Learning library for Educational Purposes.<break/>
It aims at providing a collection of simple machine learning algorithms with the
following claims:<itemize> <item>to use only ANSI Common Lisp (thus to be implementation independent)</item> <item>to be fairly easy to use so that even intermediate Common Lisp programmers should   be able to use this library instantly without pain</item> <item>to provide a tutorial-style documentation so that one should get to know this   library easily</item></itemize></documentation-string><external-symbols><function-definition id="mlep__fun__plot-values" name="plot-values" package="mlep"><lambda-list><elt>vals</elt><elt>&amp;key</elt><elt>(height 20)</elt><elt>(char x)</elt></lambda-list><documentation-string><arg arg="vals">a sequence of numbers to be plotted</arg><arg arg="height">the height in characters used for the plot</arg><arg arg="char">the character used for printing</arg><return>nothing</return>Plot the values of <code>vals</code> successively.</documentation-string></function-definition><class-definition id="mlep__class__naive-bayes" name="naive-bayes" package="mlep"><cpl><superclass status="EXTERNAL" name="standard-object" package="common-lisp"/><superclass status="INTERNAL" name="slot-object" package="sb-pcl"/><superclass status="EXTERNAL" name="t" package="common-lisp"/></cpl><subclasses/><direct-slots><slot id="mlep__slot__data-set" name="data-set" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__data-set" name="data-set" package="keyword"/></initargs><readers><reader id="mlep__symbol__data-set" name="data-set" package="mlep"/></readers><documentation-string>The data-set that is already known. (<code>set-labels</code> go hand in hand with it.)</documentation-string></slot><slot id="mlep__slot__set-labels" name="set-labels" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__set-labels" name="set-labels" package="keyword"/></initargs><readers><reader id="mlep__symbol__set-labels" name="set-labels" package="mlep"/></readers><documentation-string>The labels for <code>data-set</code>.</documentation-string></slot><slot id="mlep__slot__test-set" name="test-set" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__test-set" name="test-set" package="keyword"/></initargs><readers><reader id="mlep__symbol__test-set" name="test-set" package="mlep"/></readers><documentation-string>The data-set that has no labels and needs to be classified.</documentation-string></slot><slot id="mlep__slot__possible-data-values" name="possible-data-values" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__possible-data-values" name="possible-data-values" package="keyword"/></initargs><readers><reader id="mlep__symbol__possible-data-values" name="possible-data-values" package="mlep"/></readers><documentation-string>All possible values occurring in each attribute of <code>data-set</code>. To be pre-computed.</documentation-string></slot><slot id="mlep__slot__all-labels" name="all-labels" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__all-labels" name="all-labels" package="keyword"/></initargs><readers><reader id="mlep__symbol__all-labels" name="all-labels" package="mlep"/></readers><documentation-string>All given data-labels. To be pre-computed.</documentation-string></slot><slot id="mlep__slot__label-count" name="label-count" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__label-count" name="label-count" package="keyword"/></initargs><readers><reader id="mlep__symbol__label-count" name="label-count" package="mlep"/></readers><documentation-string>Counting of each item of a label. To be pre-computed.</documentation-string></slot><slot id="mlep__slot__prior-probabilities" name="prior-probabilities" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__prior-probabilities" name="prior-probabilities" package="keyword"/></initargs><readers><reader id="mlep__symbol__prior-probabilities" name="prior-probabilities" package="mlep"/></readers><documentation-string>The prior-probabilities of each class. To be pre-computed.</documentation-string></slot><slot id="mlep__slot__likelihoods" name="likelihoods" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="mlep__symbol__likelihoods" name="likelihoods" package="mlep"/></initargs><readers><reader id="mlep__symbol__likelihoods" name="likelihoods" package="mlep"/></readers><documentation-string>The likelihoods of a feature attribute given a class. To be pre-computed.</documentation-string></slot></direct-slots><documentation-string>Naive-bayes takes an probabilistic approach for a simple supervised clustering.</documentation-string></class-definition><class-definition id="mlep__class__k-nearest-neighbors" name="k-nearest-neighbors" package="mlep"><cpl><superclass status="EXTERNAL" name="standard-object" package="common-lisp"/><superclass status="INTERNAL" name="slot-object" package="sb-pcl"/><superclass status="EXTERNAL" name="t" package="common-lisp"/></cpl><subclasses/><direct-slots><slot id="mlep__slot__k" name="k" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__k" name="k" package="keyword"/></initargs><readers><reader id="mlep__symbol__k" name="k" package="mlep"/></readers><documentation-string>The number of neighbors to be taken into account.</documentation-string></slot><slot id="mlep__slot__data-set" name="data-set" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__data-set" name="data-set" package="keyword"/></initargs><readers><reader id="mlep__symbol__data-set" name="data-set" package="mlep"/></readers><documentation-string>The data-set that is already known. (<code>set-labels</code> go hand in hand with it.)</documentation-string></slot><slot id="mlep__slot__set-labels" name="set-labels" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__set-labels" name="set-labels" package="keyword"/></initargs><readers><reader id="mlep__symbol__set-labels" name="set-labels" package="mlep"/></readers><documentation-string>The labels for <code>data-set</code>.</documentation-string></slot><slot id="mlep__slot__distance" name="distance" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__distance" name="distance" package="keyword"/></initargs><readers><reader id="mlep__symbol__distance" name="distance" package="mlep"/></readers><documentation-string>A distance measuring function.</documentation-string></slot><slot id="mlep__slot__test-set" name="test-set" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__test-set" name="test-set" package="keyword"/></initargs><readers><reader id="mlep__symbol__test-set" name="test-set" package="mlep"/></readers><documentation-string>The data-set that has no labels and needs to be classified.</documentation-string></slot></direct-slots><documentation-string>k-nearest-neighbors is a simple supervised clustering algorithm for a known number of clusters.</documentation-string></class-definition><variable-definition id="mlep__variable___iris_" name="*iris*" package="mlep"><documentation-string>Iris flower data set by Sir Ronald Fisher (1936)<break/><a a="http://archive.ics.uci.edu/ml/datasets/Iris">http://archive.ics.uci.edu/ml/datasets/Iris</a><break/>
Attribute Information:<break/><itemize>   <item>1. sepal length in cm</item>   <item>2. sepal width in cm</item>   <item>3. petal length in cm</item>   <item>4. petal width in cm</item>   <item>5. class (Iris Setosa, Iris Versicolour, Iris Virginica)</item></itemize></documentation-string></variable-definition><class-definition id="mlep__class__max-likelihood" name="max-likelihood" package="mlep"><cpl><superclass status="EXTERNAL" name="standard-object" package="common-lisp"/><superclass status="INTERNAL" name="slot-object" package="sb-pcl"/><superclass status="EXTERNAL" name="t" package="common-lisp"/></cpl><subclasses/><direct-slots><slot id="mlep__slot__data-set" name="data-set" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__data-set" name="data-set" package="keyword"/></initargs><readers><reader id="mlep__symbol__data-set" name="data-set" package="mlep"/></readers><documentation-string>The data-set to be analyzed.</documentation-string></slot><slot id="mlep__slot__degrees-of-freedom" name="degrees-of-freedom" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__ddof" name="ddof" package="keyword"/></initargs><readers><reader id="mlep__symbol__degrees-of-freedom" name="degrees-of-freedom" package="mlep"/></readers><documentation-string>Delta Degrees of Freedom. Divisor is length of <code>data-set</code> minus <code>degrees-of-freedom</code>.</documentation-string></slot></direct-slots><documentation-string>With max-likelihood one can estimate the parameters of the normal distributed probability density function that fits the data-set.</documentation-string></class-definition><variable-definition id="mlep__variable___wages_" name="*wages*" package="mlep"><documentation-string>Determinants of Wages from the 1985 Current Population Survey<break/>
Therese Stukel<break/>
The datafile contains 534 observations on 11 variables
sampled from the Current Population Survey of 1985<break/><a a="http://lib.stat.cmu.edu/datasets/CPS_85_Wages">http://lib.stat.cmu.edu/datasets/CPS_85_Wages</a><break/>
Attribute Information:<break/><itemize><item>   1. EDUCATION: Number of years of education.</item><item>   2. SOUTH: Indicator variable for Southern Region (1=Person lives in South, 0=Person lives elsewhere).</item><item>   3. SEX: Indicator variable for sex (1=Female, 0=Male).</item><item>   4. EXPERIENCE: Number of years of work experience.</item><item>   5. UNION: Indicator variable for union membership (1=Union member, 0=Not union member).</item><item>   6. WAGE: Wage (dollars per hour).</item><item>   7. AGE: Age (years).</item><item>   8. RACE: Race (1=Other, 2=Hispanic, 3=White).</item><item>   9. OCCUPATION: Occupational category (1=Management, 2=Sales, 3=Clerical, 4=Service, 5=Professional, 6=Other).</item><item>   10. SECTOR: Sector (0=Other, 1=Manufacturing, 2=Construction).</item><item>   11. MARR: Marital Status (0=Unmarried, 1=Married)</item></itemize></documentation-string></variable-definition><function-definition id="mlep__fun__test-set" name="test-set" package="mlep"><lambda-list><elt>instance</elt></lambda-list><documentation-string><arg arg="instance">an instance of <code>k-nearest-neighbors</code> or <code>naive-bayes</code></arg><return>the test, i.e. a set that has no target labels and needs to be classified.</return>Get the test-set.</documentation-string></function-definition><function-definition id="mlep__fun__distance" name="distance" package="mlep"><lambda-list><elt>instance</elt></lambda-list><documentation-string><arg arg="instance">an instance of <code>k-means</code> or <code>k-nearest-neighbors</code></arg><return>the function for calculating the distance for <code>instance</code></return>Get the function for calculating the distance for <code>instance</code>, e.g. <code>#'euclidian-distance</code>.</documentation-string></function-definition><class-definition id="mlep__class__perceptron" name="perceptron" package="mlep"><cpl><superclass status="EXTERNAL" name="standard-object" package="common-lisp"/><superclass status="INTERNAL" name="slot-object" package="sb-pcl"/><superclass status="EXTERNAL" name="t" package="common-lisp"/></cpl><subclasses/><direct-slots><slot id="mlep__slot__data-set" name="data-set" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__data-set" name="data-set" package="keyword"/></initargs><readers><reader id="mlep__symbol__data-set" name="data-set" package="mlep"/></readers><documentation-string>The data-set to be analyzed.</documentation-string></slot><slot id="mlep__slot__set-labels" name="set-labels" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__set-labels" name="set-labels" package="keyword"/></initargs><readers><reader id="mlep__symbol__set-labels" name="set-labels" package="mlep"/></readers><documentation-string>The output-values for <code>data-set</code>.</documentation-string></slot><slot id="mlep__slot__weights" name="weights" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__weights" name="weights" package="keyword"/></initargs><readers><reader id="mlep__symbol__weights" name="weights" package="mlep"/></readers><documentation-string>The weights from input to output values.</documentation-string></slot><slot id="mlep__slot__max-weight-init-value" name="max-weight-init-value" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__max-weight-init-value" name="max-weight-init-value" package="keyword"/></initargs><readers><reader id="mlep__symbol__max-weight-init-value" name="max-weight-init-value" package="mlep"/></readers><documentation-string>The maximum value for initializing the weights.</documentation-string></slot><slot id="mlep__slot__activation-function" name="activation-function" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__activation-function" name="activation-function" package="keyword"/></initargs><readers><reader id="mlep__symbol__activation-function" name="activation-function" package="mlep"/></readers><documentation-string>The activation function, usually a Heaviside step function.</documentation-string></slot><slot id="mlep__slot__learning-rate" name="learning-rate" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__learning-rate" name="learning-rate" package="keyword"/></initargs><readers><reader id="mlep__symbol__learning-rate" name="learning-rate" package="mlep"/></readers><documentation-string>The learning rate.</documentation-string></slot></direct-slots><documentation-string>A perceptron is a very simple neuron model and turns out to be a linear classificator.</documentation-string></class-definition><class-definition id="mlep__class__k-means" name="k-means" package="mlep"><cpl><superclass status="EXTERNAL" name="standard-object" package="common-lisp"/><superclass status="INTERNAL" name="slot-object" package="sb-pcl"/><superclass status="EXTERNAL" name="t" package="common-lisp"/></cpl><subclasses/><direct-slots><slot id="mlep__slot__k" name="k" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__k" name="k" package="keyword"/></initargs><readers><reader id="mlep__symbol__k" name="k" package="mlep"/></readers><documentation-string>The number of groups/clusters to be determined.</documentation-string></slot><slot id="mlep__slot__data-set" name="data-set" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__data-set" name="data-set" package="keyword"/></initargs><readers><reader id="mlep__symbol__data-set" name="data-set" package="mlep"/></readers><documentation-string>The data-set to be analyzed.</documentation-string></slot><slot id="mlep__slot__distance" name="distance" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__distance" name="distance" package="keyword"/></initargs><readers><reader id="mlep__symbol__distance" name="distance" package="mlep"/></readers><documentation-string>A distance measuring function.</documentation-string></slot><slot id="mlep__slot__means" name="means" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__means" name="means" package="keyword"/></initargs><readers><reader id="mlep__symbol__means" name="means" package="mlep"/></readers><documentation-string>The means of the data points.</documentation-string></slot></direct-slots><documentation-string>k-means is a simple unsupervised clustering algorithm for a known number of clusters.</documentation-string></class-definition><function-definition id="mlep__fun__order" name="order" package="mlep"><lambda-list><elt>instance</elt></lambda-list><documentation-string><arg arg="instance">an instance of <code>markov-chain</code></arg><return>the order of the markov chain</return>The order of a markov chain determines how much past events are considered for producing a current event.</documentation-string></function-definition><function-definition id="mlep__fun__probabilities" name="probabilities" package="mlep"><lambda-list><elt>instance</elt></lambda-list><documentation-string><arg arg="instance">an instance of <code>markov-chain</code></arg><return>the probabilities of the markov chain</return>Get the probability matrix (or tensor) -- it's rank is <code>order+1</code>.</documentation-string></function-definition><function-definition id="mlep__fun__set-labels" name="set-labels" package="mlep"><lambda-list><elt>instance</elt></lambda-list><documentation-string><arg arg="instance">an instance of <code>k-nearest-neighbors</code>, <code>naive-bayes</code>, <code>neuronal-network</code> or <code>perceptron</code></arg><return>the target labels for <code>data-set</code> of a supervised learning algorithm.</return>Get the target labels.</documentation-string></function-definition><function-definition id="mlep__fun__k" name="k" package="mlep"><lambda-list><elt>instance</elt></lambda-list><documentation-string><arg arg="instance">an instance of <code>k-means</code> or <code>k-nearest-neighbors</code></arg><return>the parameter <code>k</code></return><code>k</code> determines how many means are assumed (for <code>k-means</code>) resp. how many neighbors are considered (for <code>k-nearest-neighbors</code>).</documentation-string></function-definition><variable-definition id="mlep__variable___heights-weights_" name="*heights-weights*" package="mlep"><documentation-string>SOCR Data Dinov 020108 HeightsWeights<break/>
Human Height and Weight are mostly hereditable, but lifestyles, diet, health and environmental factors also play a role in determining individual's physical characteristics. The dataset below contains 25,000 records of human heights and weights. These data were obtained in 1993 by a Growth Survey of 25,000 children from birth to 18 years of age recruited from Maternal and Child Health Centres (MCHC) and schools and were used to develop Hong Kong's current growth charts for weight, height, weight-for-age, weight-for-height and body mass index (BMI). See also the Major League Baseball Players Height and Weight dataset.<break/><a a="http://wiki.stat.ucla.edu/socr/index.php/SOCR_Data_Dinov_020108_HeightsWeights">http://wiki.stat.ucla.edu/socr/index.php/SOCR_Data_Dinov_020108_HeightsWeights</a><break/>
Attribute Information:<break/><itemize><item>1. Height (Inches)</item><item>2. Weight (Pounds)</item></itemize></documentation-string></variable-definition><function-definition id="mlep__fun__analyze" name="analyze" package="mlep"><lambda-list><elt>instance</elt><elt>input</elt></lambda-list><documentation-string><arg arg="instance">an instance of <code>markov-chain</code></arg><arg arg="input">some input data</arg><return>the probability of <code>input</code></return>Check the probability of <code>input</code> being generated by <code>instance</code>.</documentation-string></function-definition><function-definition id="mlep__fun__data-set" name="data-set" package="mlep"><lambda-list><elt>instance</elt></lambda-list><documentation-string><arg arg="instance">an instance of any <code>mlep</code> learning algorithm</arg><return>the data-set of <code>instance</code></return>Get the data-set of <code>instance</code>.</documentation-string></function-definition><class-definition id="mlep__class__markov-chain" name="markov-chain" package="mlep"><cpl><superclass status="EXTERNAL" name="standard-object" package="common-lisp"/><superclass status="INTERNAL" name="slot-object" package="sb-pcl"/><superclass status="EXTERNAL" name="t" package="common-lisp"/></cpl><subclasses/><direct-slots><slot id="mlep__slot__data-set" name="data-set" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__data-set" name="data-set" package="keyword"/></initargs><readers><reader id="mlep__symbol__data-set" name="data-set" package="mlep"/></readers><documentation-string>The data-set to be analyzed.</documentation-string></slot><slot id="mlep__slot__order" name="order" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__order" name="order" package="keyword"/></initargs><readers><reader id="mlep__symbol__order" name="order" package="mlep"/></readers><documentation-string>The order of the markov chain.</documentation-string></slot><slot id="mlep__slot__unique" name="unique" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__unique" name="unique" package="keyword"/></initargs><readers><reader id="mlep__symbol__unique" name="unique" package="mlep"/></readers><documentation-string>Unique values of data-set</documentation-string></slot><slot id="mlep__slot__probabilities" name="probabilities" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__probabilities" name="probabilities" package="keyword"/></initargs><readers><reader id="mlep__symbol__probabilities" name="probabilities" package="mlep"/></readers><documentation-string>A matrix/tensor with probabilities.</documentation-string></slot></direct-slots><documentation-string>A Markov-Chain.</documentation-string></class-definition><class-definition id="mlep__class__neuronal-network" name="neuronal-network" package="mlep"><cpl><superclass status="EXTERNAL" name="standard-object" package="common-lisp"/><superclass status="INTERNAL" name="slot-object" package="sb-pcl"/><superclass status="EXTERNAL" name="t" package="common-lisp"/></cpl><subclasses/><direct-slots><slot id="mlep__slot__data-set" name="data-set" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__data-set" name="data-set" package="keyword"/></initargs><readers><reader id="mlep__symbol__data-set" name="data-set" package="mlep"/></readers><documentation-string>The data-set to be analyzed.</documentation-string></slot><slot id="mlep__slot__set-labels" name="set-labels" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__set-labels" name="set-labels" package="keyword"/></initargs><readers><reader id="mlep__symbol__set-labels" name="set-labels" package="mlep"/></readers><documentation-string>The output-values for <code>data-set</code>.</documentation-string></slot><slot id="mlep__slot__net-structure" name="net-structure" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__net-structure" name="net-structure" package="keyword"/></initargs><readers><reader id="mlep__symbol__net-structure" name="net-structure" package="mlep"/></readers><documentation-string>The net-structure of the net. (Neurons per layer.)</documentation-string></slot><slot id="mlep__slot__weights" name="weights" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__weights" name="weights" package="keyword"/></initargs><readers><reader id="mlep__symbol__weights" name="weights" package="mlep"/></readers><documentation-string>The weights from input to output values.</documentation-string></slot><slot id="mlep__slot__output-net" name="output-net" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__output-net" name="output-net" package="keyword"/></initargs><readers><reader id="mlep__symbol__output-net" name="output-net" package="mlep"/></readers><documentation-string>The output of all neurons of the network.</documentation-string></slot><slot id="mlep__slot__weight-init-range" name="weight-init-range" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__weight-init-range" name="weight-init-range" package="keyword"/></initargs><readers><reader id="mlep__symbol__weight-init-range" name="weight-init-range" package="mlep"/></readers><documentation-string>The maximum range for initializing the weights.</documentation-string></slot><slot id="mlep__slot__activation-function" name="activation-function" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__activation-function" name="activation-function" package="keyword"/></initargs><readers><reader id="mlep__symbol__activation-function" name="activation-function" package="mlep"/></readers><documentation-string>The activation function, usually a Heaviside step function.</documentation-string></slot><slot id="mlep__slot__learning-rate" name="learning-rate" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__learning-rate" name="learning-rate" package="keyword"/></initargs><readers><reader id="mlep__symbol__learning-rate" name="learning-rate" package="mlep"/></readers><documentation-string>The learning rate.</documentation-string></slot></direct-slots><documentation-string>A fully-connected Feed-Forward Multi-Layer Perceptron.</documentation-string></class-definition><function-definition id="mlep__fun__random-from-to" name="random-from-to" package="mlep"><lambda-list><elt>from</elt><elt>to</elt><elt>&amp;key</elt><elt>(state *random-state*)</elt></lambda-list><documentation-string><arg arg="from">the lower bound (inclusive)</arg><arg arg="to">the upper bound (exclusive)</arg><arg arg="state">a random state object containing information used by the pseudo-random number generator</arg><return>a random number</return>Gives a random number in certain range.</documentation-string></function-definition><function-definition id="mlep__fun__synthesize" name="synthesize" package="mlep"><lambda-list><elt>instance</elt><elt>&amp;key</elt><elt>(start)</elt><elt>(howmany 10)</elt></lambda-list><documentation-string><arg arg="instance">an instance of <code>markov-chain</code></arg><arg arg="start">1) the symbol <code>random</code> -- a new random sequence as beginning is generated; 2) <code>nil</code> (default) -- a literal subsequence with random starting index is taken as beginning, 3) a list with an user given starting sequence</arg><arg arg="howmany">number of elements to be synthesized</arg>Synthesize some data.</documentation-string></function-definition><variable-definition id="mlep__variable___lenses_" name="*lenses*" package="mlep"><documentation-string>Lenses Data Set by J. Cendrowska (1987)<break/><a a="https://archive.ics.uci.edu/ml/datasets/Lenses">https://archive.ics.uci.edu/ml/datasets/Lenses</a><break/>
Attribute Information:<break/><itemize><item>1. age of the patient (1 = young, 2 = pre-presbyopic, 3 = presbyopic)</item><item>2. spectacle prescription (1 = myope, 2 = hypermetrope)</item><item>3. astigmatic (1 = no, 2 = yes)</item><item>4. tear production rate (1 = reduced, 2 = normal)</item><item>5. class <itemize><item>1 = the patient should be fitted with hard contact lenses,</item>             <item>2 = the patient should be fitted with soft contact lenses,</item>             <item>3 = the patient should not be fitted with contact lenses.</item></itemize></item></itemize></documentation-string></variable-definition><function-definition id="mlep__fun__unique" name="unique" package="mlep"><lambda-list><elt>instance</elt></lambda-list><documentation-string><arg arg="instance">an instance of <code>markov-chain</code></arg><return>all unique elements in <code>data-set</code></return>Get all unique values are considered by the chain.</documentation-string></function-definition><function-definition id="mlep__fun__learning-rate" name="learning-rate" package="mlep"><lambda-list><elt>instance</elt></lambda-list><documentation-string><arg arg="instance">an instance of <code>neuronal-network</code> or <code>perceptron</code></arg><return>the learning-rate</return>The learning rate controls the size of change during updating the weights.</documentation-string></function-definition><function-definition id="mlep__fun__plot-points" name="plot-points" package="mlep"><lambda-list><elt>vals</elt><elt>&amp;key</elt><elt>(height 20)</elt><elt>(width 80)</elt><elt>(char x)</elt></lambda-list><documentation-string><arg arg="vals">a list of list with x/y-points or a 2d-array -- <code>((x1 y1) ... (xn yn))</code> or <code>#2a((x1 y1) ... (xn yn))</code></arg><arg arg="height">the height in characters used for the plot</arg><arg arg="width">the width in characters used for the plot</arg><arg arg="char">the character used for printing</arg><return>nothing</return>Plotting points with x/y-coordinates.</documentation-string></function-definition><function-definition id="mlep__fun__classify" name="classify" package="mlep"><lambda-list><elt>instance</elt><elt>&amp;key</elt><elt>new-data-set</elt><elt>verbose</elt></lambda-list><documentation-string><arg arg="instance">an instance of <code>k-means</code>, <code>perceptron</code> or <code>neuronal-network</code></arg><arg arg="new-data-set">use <code>new-data-set</code> instead of the internal <code>data-set</code></arg><arg arg="verbose">print some more information (only taken into account for <code>neuronal-network</code>)</arg><return>a list with a classification number according to each sample in the classified data-set</return>Classifying some data-set.</documentation-string></function-definition><function-definition id="mlep__fun__means" name="means" package="mlep"><lambda-list><elt>instance</elt></lambda-list><documentation-string><arg arg="instance">an instance of <code>k-means</code> or <code>principal-component-analysis</code></arg><return>the current means</return>Get the current means.</documentation-string></function-definition><function-definition id="mlep__fun__forward" name="forward" package="mlep"><lambda-list><elt>instance</elt><elt>&amp;key</elt><elt>input</elt></lambda-list><documentation-string><arg arg="instance">an instance of <code>neuronal-network</code></arg><arg arg="input">the input data to be considered</arg><return>the output of the <code>neuronal-network</code> given the <code>input</code></return>Computes a forward path through the network and gives its output.</documentation-string></function-definition><function-definition id="mlep__fun__run" name="run" package="mlep"><lambda-list><elt>instance</elt><elt>&amp;key</elt><elt>(epochs 100)</elt><elt>(threshold 0.1)</elt></lambda-list><documentation-string><arg arg="instance">an instance of any <code>mlep</code> learning algorithm</arg><arg arg="threshold">a threshold that is the minimum global error to be achieved -- iterative training runs until threshold is reached (supported by <code>perceptron</code>)</arg><arg arg="epochs">number of how often a iterative algorithm should be performed (supported by <code>k-means</code> and <code>neuronal-network</code>)</arg><return>depends on the learning algorithm:<itemize><item><code>k-means</code>: the computed means</item><item><code>k-nearest-neighbors</code>: the classes assigned to <code>test-set</code></item><item><code>max-likelihood</code>: a list with the first item being the mean and the second one being the co-variance matrix of the normal distribution</item><item><code>markov-chain</code>: the probability matrix (or tensor)</item><item><code>naive-bayes</code>: the classes assigned to <code>test-set</code></item><item><code>neuronal-network</code>: nothing</item><item><code>perceptron</code>: nothing</item><item><code>principal-component-analysis</code>: list with three matrices - <code>unitary-matrix1 U</code> (orthogonal matrix), <code>unitary-matrix2 Vt</code> (orthogonal matrix) and <code>singular-values</code> (a diagonal matrix with the diagonal elements being the singular values called <code>D</code>; <code>UxDxVt</code> should be a reconstruction of the input matrix)</item></itemize></return>A general interface for 'running' a learning algorithm.</documentation-string></function-definition></external-symbols><internal-symbols><function-definition id="mlep__fun__scalar-product" name="scalar-product" package="mlep"><lambda-list><elt>x1</elt><elt>x2</elt></lambda-list><documentation-string>Computes the scalar product (aka dot product aka inner product) of two vectors/lists.</documentation-string></function-definition><function-definition id="mlep__fun__histogram" name="histogram" package="mlep"><lambda-list><elt>vector</elt></lambda-list><documentation-string>Count all occurrences in vector. Returns list of all unique items in vector and their frequencies.</documentation-string></function-definition><function-definition id="mlep__fun__altern" name="altern" package="mlep"><lambda-list><elt>boul</elt><elt>prob</elt></lambda-list></function-definition><function-definition id="mlep__fun__prior-probabilities" name="prior-probabilities" package="mlep"><lambda-list><elt>object</elt></lambda-list></function-definition><function-definition id="mlep__fun__get-overall-error" name="get-overall-error" package="mlep"><lambda-list><elt>all-input</elt><elt>desired</elt><elt>activation-function</elt><elt>weights</elt></lambda-list></function-definition><function-definition id="mlep__fun__max-weight-init-value" name="max-weight-init-value" package="mlep"><lambda-list><elt>object</elt></lambda-list></function-definition><function-definition id="mlep__fun__map-pointwise" name="map-pointwise" package="mlep"><lambda-list><elt>fn</elt><elt>&amp;rest</elt><elt>arrays</elt></lambda-list><documentation-string>Calls `function' to one or more `arrays' pointwise.</documentation-string></function-definition><function-definition id="mlep__fun__range" name="range" package="mlep"><lambda-list><elt>from</elt><elt>to</elt><elt>&amp;optional</elt><elt>(step 1)</elt></lambda-list><documentation-string>Gives a list with all numbers from `FROM' to (exclusive) `TO'.</documentation-string></function-definition><function-definition id="mlep__fun__diff" name="diff" package="mlep"><lambda-list><elt>func</elt></lambda-list></function-definition><macro-definition id="mlep__fun__dotimes-fromto" name="dotimes-fromto" package="mlep"><lambda-list><elt>(var from to &amp;optional result)</elt><elt>&amp;body</elt><elt>body</elt></lambda-list></macro-definition><function-definition id="mlep__fun__transpose-array" name="transpose-array" package="mlep"><lambda-list><elt>array</elt></lambda-list><documentation-string>Transpose an 2-dimensional array.</documentation-string></function-definition><function-definition id="mlep__fun__matrix-expt" name="matrix-expt" package="mlep"><lambda-list><elt>matrix</elt><elt>exp</elt></lambda-list><documentation-string>Takes the first argument (a matrix) and multiplies it by itself exp times</documentation-string></function-definition><function-definition id="mlep__fun__get-row-ranges" name="get-row-ranges" package="mlep"><lambda-list><elt>set</elt><elt>&amp;key</elt><elt>(key #'identity)</elt></lambda-list><documentation-string>SET is a two-dimensional list or array. Gets the minimal and maximal value of each row(i.e. sublist) of SET.</documentation-string></function-definition><function-definition id="mlep__fun__sigmoid" name="sigmoid" package="mlep"><lambda-list><elt>x</elt></lambda-list></function-definition><macro-definition id="mlep__fun__dolist-with-index" name="dolist-with-index" package="mlep"><lambda-list><elt>(index list-item list &amp;optional result)</elt><elt>&amp;body</elt><elt>body</elt></lambda-list></macro-definition><function-definition id="mlep__fun__list-to-vector" name="list-to-vector" package="mlep"><lambda-list><elt>list</elt><elt>&amp;key</elt><elt>(element-type t)</elt></lambda-list><documentation-string>Converts a list to a vector.</documentation-string></function-definition><function-definition id="mlep__fun__likelihoods" name="likelihoods" package="mlep"><lambda-list><elt>object</elt></lambda-list></function-definition><function-definition id="mlep__fun__vector-to-2d-col" name="vector-to-2d-col" package="mlep"><lambda-list><elt>vec</elt></lambda-list></function-definition><function-definition id="mlep__fun__get-row-ranges-array" name="get-row-ranges-array" package="mlep"><lambda-list><elt>set</elt><elt>&amp;key</elt><elt>(key #'identity)</elt></lambda-list></function-definition><function-definition id="mlep__fun__get-column-ranges" name="get-column-ranges" package="mlep"><lambda-list><elt>set</elt><elt>&amp;key</elt><elt>(key #'identity)</elt></lambda-list><documentation-string>SET is a two-dimensional list or array. Gets the minmal and maximal value of eachcolumn of SET. Column means the corresponding nth values of each sublist.</documentation-string></function-definition><function-definition id="mlep__fun__transpose" name="transpose" package="mlep"><lambda-list><elt>x</elt></lambda-list><documentation-string>Transpose 2-dimensional list or array.</documentation-string></function-definition><function-definition id="mlep__fun__net-structure-to-weights" name="net-structure-to-weights" package="mlep"><lambda-list><elt>net-structure</elt><elt>&amp;optional</elt><elt>weight-init-range</elt></lambda-list></function-definition><function-definition id="mlep__fun__possible-data-values" name="possible-data-values" package="mlep"><lambda-list><elt>object</elt></lambda-list></function-definition><function-definition id="mlep__fun__euclidian-distance" name="euclidian-distance" package="mlep"><lambda-list><elt>p1</elt><elt>p2</elt></lambda-list><documentation-string>Gives the euclidian distance between to points of arbitrary dimension.</documentation-string></function-definition><function-definition id="mlep__fun__backprop" name="backprop" package="mlep"><lambda-list><elt>instance</elt><elt>input</elt><elt>wanted</elt></lambda-list><documentation-string>Adjust weights with backpropagation.</documentation-string></function-definition><function-definition id="mlep__fun__d-sigmoid" name="d-sigmoid" package="mlep"><lambda-list><elt>x</elt></lambda-list></function-definition><function-definition id="mlep__fun__normalize-tensor" name="normalize-tensor" package="mlep"><lambda-list><elt>tensor</elt></lambda-list></function-definition><function-definition id="mlep__fun__degrees-of-freedom" name="degrees-of-freedom" package="mlep"><lambda-list><elt>object</elt></lambda-list></function-definition><function-definition id="mlep__fun__compute-possible-data-values" name="compute-possible-data-values" package="mlep"><lambda-list><elt>data-set</elt></lambda-list></function-definition><function-definition id="mlep__fun__determinant-helper" name="determinant-helper" package="mlep"><lambda-list><elt>matrix</elt></lambda-list></function-definition><function-definition id="mlep__fun__all-positions" name="all-positions" package="mlep"><lambda-list><elt>item</elt><elt>list</elt><elt>&amp;key</elt><elt>(test #'eql)</elt><elt>(key #'identity)</elt></lambda-list><documentation-string>Gets the indices of all elements in LIST that safisfy the TEST.</documentation-string></function-definition><function-definition id="mlep__fun__k-maxmin-idx" name="k-maxmin-idx" package="mlep"><lambda-list><elt>vector</elt><elt>&amp;key</elt><elt>(k 1)</elt><elt>(key #'&lt;)</elt></lambda-list><documentation-string>Get the index of k max/min values in vector.</documentation-string></function-definition><macro-definition id="mlep__fun__do-lists" name="do-lists" package="mlep"><lambda-list><elt>((&amp;rest vars) (&amp;rest lists) &amp;optional result)</elt><elt>&amp;body</elt><elt>body</elt></lambda-list></macro-definition><variable-definition id="mlep__variable___diff-function-dict_" name="*diff-function-dict*" package="mlep"/><function-definition id="mlep__fun__all-labels" name="all-labels" package="mlep"><lambda-list><elt>object</elt></lambda-list></function-definition><function-definition id="mlep__fun__min-arg" name="min-arg" package="mlep"><lambda-list><elt>l</elt></lambda-list><documentation-string>Gets the index of the minimum value of `l'.</documentation-string></function-definition><function-definition id="mlep__fun__d-step-function" name="d-step-function" package="mlep"><lambda-list><elt>x</elt></lambda-list></function-definition><function-definition id="mlep__fun__get-actual-output" name="get-actual-output" package="mlep"><lambda-list><elt>activation-function</elt><elt>weights</elt><elt>input</elt></lambda-list></function-definition><function-definition id="mlep__fun__square" name="square" package="mlep"><lambda-list><elt>n</elt></lambda-list><documentation-string>Squares number N.</documentation-string></function-definition><function-definition id="mlep__fun__determinant" name="determinant" package="mlep"><lambda-list><elt>matrix</elt></lambda-list><documentation-string>Computes the determinant of `matrix' - which must a square matrix of rank 2..</documentation-string></function-definition><function-definition id="mlep__fun__step-function" name="step-function" package="mlep"><lambda-list><elt>x</elt></lambda-list></function-definition><function-definition id="mlep__fun__row-of-array" name="row-of-array" package="mlep"><lambda-list><elt>array</elt><elt>row</elt></lambda-list><documentation-string>Return row of 2d array as vector</documentation-string></function-definition><function-definition id="mlep__fun__net-structure" name="net-structure" package="mlep"><lambda-list><elt>object</elt></lambda-list></function-definition><function-definition id="mlep__fun__d-tanh" name="d-tanh" package="mlep"><lambda-list><elt>x</elt></lambda-list></function-definition><function-definition id="mlep__fun__output-net" name="output-net" package="mlep"><lambda-list><elt>object</elt></lambda-list></function-definition><function-definition id="mlep__fun__transpose-list" name="transpose-list" package="mlep"><lambda-list><elt>l</elt></lambda-list><documentation-string>Transpose a list of lists.</documentation-string></function-definition><function-definition id="mlep__fun__shuffle" name="shuffle" package="mlep"><lambda-list><elt>x</elt></lambda-list><documentation-string>Shuffle a list.</documentation-string></function-definition><function-definition id="mlep__fun__label-count" name="label-count" package="mlep"><lambda-list><elt>object</elt></lambda-list></function-definition><function-definition id="mlep__fun__list-to-2d-array" name="list-to-2d-array" package="mlep"><lambda-list><elt>list</elt><elt>&amp;key</elt><elt>(element-type t)</elt></lambda-list><documentation-string>Converts a list of list to a 2-dimensional array.</documentation-string></function-definition><function-definition id="mlep__fun__compute-likelihoods" name="compute-likelihoods" package="mlep"><lambda-list><elt>set</elt><elt>data-labels</elt><elt>all-labels</elt><elt>label-count</elt><elt>possible-data-values</elt></lambda-list></function-definition><function-definition id="mlep__fun__initialize" name="initialize" package="mlep"><lambda-list><elt>instance</elt></lambda-list><documentation-string>Initialize the arguments of INSTANCE.</documentation-string></function-definition><function-definition id="mlep__fun__activation-function" name="activation-function" package="mlep"><lambda-list><elt>object</elt></lambda-list></function-definition><function-definition id="mlep__fun__weight-init-range" name="weight-init-range" package="mlep"><lambda-list><elt>object</elt></lambda-list></function-definition><function-definition id="mlep__fun__multiply-matrices" name="multiply-matrices" package="mlep"><lambda-list><elt>matrix-0</elt><elt>matrix-1</elt></lambda-list><documentation-string>Takes two 2D arrays and returns their product, or an error if they cannot be multiplied</documentation-string></function-definition><function-definition id="mlep__fun__compute-prior-probabilities" name="compute-prior-probabilities" package="mlep"><lambda-list><elt>data-labels</elt><elt>label-count</elt></lambda-list></function-definition><function-definition id="mlep__fun__col-of-array" name="col-of-array" package="mlep"><lambda-list><elt>array</elt><elt>col</elt></lambda-list><documentation-string>Return column of 2d array as vector</documentation-string></function-definition><function-definition id="mlep__fun__weights" name="weights" package="mlep"><lambda-list><elt>object</elt></lambda-list></function-definition><variable-definition id="mlep__variable__+e+" name="+e+" package="mlep"/><function-definition id="mlep__fun__outer-product" name="outer-product" package="mlep"><lambda-list><elt>x1</elt><elt>x2</elt></lambda-list><documentation-string>Computes the outer product (aka tensor product) of two vectors/lists `x1' and `x2'.</documentation-string></function-definition><function-definition id="mlep__fun__net-structure-to-array" name="net-structure-to-array" package="mlep"><lambda-list><elt>net-structure</elt><elt>&amp;optional</elt><elt>(value 0.0d0)</elt></lambda-list></function-definition><function-definition id="mlep__fun__2d-col-to-vector" name="2d-col-to-vector" package="mlep"><lambda-list><elt>array</elt></lambda-list></function-definition><function-definition id="mlep__fun__get-row-ranges-list" name="get-row-ranges-list" package="mlep"><lambda-list><elt>set</elt><elt>&amp;key</elt><elt>(key #'identity)</elt></lambda-list></function-definition><function-definition id="mlep__fun__matrix-identity" name="matrix-identity" package="mlep"><lambda-list><elt>dim</elt><elt>&amp;key</elt><elt>(element-type t)</elt></lambda-list><documentation-string>Creates a new identity matrix of size dim*dim</documentation-string></function-definition><function-definition id="mlep__fun__mean" name="mean" package="mlep"><lambda-list><elt>l</elt></lambda-list><documentation-string>Gets the mean of `l'.</documentation-string></function-definition><function-definition id="mlep__fun__max-arg" name="max-arg" package="mlep"><lambda-list><elt>l</elt></lambda-list><documentation-string>Gets the index of the maximum value of `l'.</documentation-string></function-definition></internal-symbols></package><package name="mlep-add" id="mlep-add"><documentation-string><code>mlep-add</code> contains all parts of <code>mlep</code> that don't run without dependencies. Currently <a a="https://github.com/tpapp/lla"><code>lla</code></a> and <a a="https://github.com/tpapp/cl-num-utils"><code>cl-num-utils</code></a> are needed.</documentation-string><external-symbols><function-definition id="mlep-add__fun__transform" name="transform" package="mlep-add"><lambda-list><elt>instance</elt><elt>&amp;key</elt><elt>components</elt><elt>inverse</elt><elt>new-data</elt></lambda-list><documentation-string><arg arg="instance">an instance of <code>principal-component-analysis</code></arg><arg arg="components">a number that states how many dimensions should be used for a transformation (default is <code>nil</code> which means that it should use all dimensions of <code>data-set</code></arg><arg arg="inverse">do an inverse transformation (<code>t</code> or <code>nil</code>, default: <code>nil</code>)</arg><arg arg="new-data">do the transformation on this data-set (default is <code>nil</code> which means, that it should use <code>data-set</code>)</arg><return>the transformed data-set</return>Project some data on its principal components.</documentation-string></function-definition><class-definition id="mlep-add__class__principal-component-analysis" name="principal-component-analysis" package="mlep-add"><cpl><superclass status="EXTERNAL" name="standard-object" package="common-lisp"/><superclass status="INTERNAL" name="slot-object" package="sb-pcl"/><superclass status="EXTERNAL" name="t" package="common-lisp"/></cpl><subclasses/><direct-slots><slot id="mlep__slot__data-set" name="data-set" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__data-set" name="data-set" package="keyword"/></initargs><readers><reader id="mlep__symbol__data-set" name="data-set" package="mlep"/></readers><documentation-string>The data-set to be analyzed.</documentation-string></slot><slot id="mlep-add__slot__data" name="data" package="mlep-add" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__data" name="data" package="keyword"/></initargs><readers><reader id="mlep-add__symbol__data" name="data" package="mlep-add"/></readers><documentation-string>Converted data.</documentation-string></slot><slot id="mlep__slot__means" name="means" package="mlep" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__means" name="means" package="keyword"/></initargs><readers><reader id="mlep__symbol__means" name="means" package="mlep"/></readers><documentation-string>Means of data.</documentation-string></slot><slot id="mlep-add__slot__unitary-matrix1" name="unitary-matrix1" package="mlep-add" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__unitary-matrix1" name="unitary-matrix1" package="keyword"/></initargs><readers><reader id="mlep-add__symbol__unitary-matrix1" name="unitary-matrix1" package="mlep-add"/></readers><documentation-string>Unitary matrix U.</documentation-string></slot><slot id="mlep-add__slot__unitary-matrix2" name="unitary-matrix2" package="mlep-add" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__unitary-matrix2" name="unitary-matrix2" package="keyword"/></initargs><readers><reader id="mlep-add__symbol__unitary-matrix2" name="unitary-matrix2" package="mlep-add"/></readers><documentation-string>Unitary matrix V.</documentation-string></slot><slot id="mlep-add__slot__singular-values" name="singular-values" package="mlep-add" allocation="keyword__symbol__instance" type="T"><initargs><initarg id="keyword__symbol__singular-values" name="singular-values" package="keyword"/></initargs><readers><reader id="mlep-add__symbol__singular-values" name="singular-values" package="mlep-add"/></readers><documentation-string>The singular values for every matrix.</documentation-string></slot></direct-slots><documentation-string>Principal Component Analysis by Singular Value Decomposition</documentation-string></class-definition></external-symbols><internal-symbols><function-definition id="lla__fun__svd-vt" name="svd-vt" package="lla"><lambda-list><elt>instance</elt></lambda-list></function-definition><function-definition id="mlep-add__fun__singular-values" name="singular-values" package="mlep-add"><lambda-list><elt>object</elt></lambda-list></function-definition><function-definition id="mlep__fun__map-pointwise" name="map-pointwise" package="mlep"><lambda-list><elt>fn</elt><elt>&amp;rest</elt><elt>arrays</elt></lambda-list><documentation-string>Calls `function' to one or more `arrays' pointwise.</documentation-string></function-definition><function-definition id="lla__fun__svd-d" name="svd-d" package="lla"><lambda-list><elt>instance</elt></lambda-list></function-definition><function-definition id="cl-num-utils.matrix__fun__diagonal-matrix-elements" name="diagonal-matrix-elements" package="cl-num-utils.matrix"><lambda-list><elt>instance</elt></lambda-list></function-definition><function-definition id="lla__fun__svd" name="svd" package="lla"><lambda-list><elt>a</elt><elt>&amp;optional</elt><elt>vectors</elt></lambda-list><documentation-string>Return singular value decomposition A.<break/>
  VECTORS determines how singular vectors are calculated:<break/>
  - NIL sets U and VT to NIL
  - :ALL makes U and VT square, with dimensions conforming to A
  - :THIN makes the larger of U and VT rectangular.  This means that not all
    of the singular vectors are calculates, and saves computational time when    A is far from square.</documentation-string></function-definition><class-definition id="lla__class__svd" name="svd" package="lla"><cpl><superclass status="EXTERNAL" name="structure-object" package="common-lisp"/><superclass status="INTERNAL" name="slot-object" package="sb-pcl"/><superclass status="EXTERNAL" name="t" package="common-lisp"/></cpl><subclasses/><documentation-string>Singular value decomposition.  Singular values are in S, in descending order.  U and VT may be NIL in case they are not computed.</documentation-string></class-definition><function-definition id="mlep-add__fun__unitary-matrix1" name="unitary-matrix1" package="mlep-add"><lambda-list><elt>object</elt></lambda-list></function-definition><function-definition id="mlep__fun__list-to-2d-array" name="list-to-2d-array" package="mlep"><lambda-list><elt>list</elt><elt>&amp;key</elt><elt>(element-type t)</elt></lambda-list><documentation-string>Converts a list of list to a 2-dimensional array.</documentation-string></function-definition><function-definition id="mlep__fun__multiply-matrices" name="multiply-matrices" package="mlep"><lambda-list><elt>matrix-0</elt><elt>matrix-1</elt></lambda-list><documentation-string>Takes two 2D arrays and returns their product, or an error if they cannot be multiplied</documentation-string></function-definition><function-definition id="mlep-add__fun__data" name="data" package="mlep-add"><lambda-list><elt>object</elt></lambda-list></function-definition><function-definition id="mlep-add__fun__unitary-matrix2" name="unitary-matrix2" package="mlep-add"><lambda-list><elt>object</elt></lambda-list></function-definition><function-definition id="lla__fun__svd-u" name="svd-u" package="lla"><lambda-list><elt>instance</elt></lambda-list></function-definition><function-definition id="lla__fun__svd" name="svd" package="lla"><lambda-list><elt>a</elt><elt>&amp;optional</elt><elt>vectors</elt></lambda-list><documentation-string>Return singular value decomposition A.<break/>
  VECTORS determines how singular vectors are calculated:<break/>
  - NIL sets U and VT to NIL
  - :ALL makes U and VT square, with dimensions conforming to A
  - :THIN makes the larger of U and VT rectangular.  This means that not all
    of the singular vectors are calculates, and saves computational time when    A is far from square.</documentation-string></function-definition><class-definition id="lla__class__svd" name="svd" package="lla"><cpl><superclass status="EXTERNAL" name="structure-object" package="common-lisp"/><superclass status="INTERNAL" name="slot-object" package="sb-pcl"/><superclass status="EXTERNAL" name="t" package="common-lisp"/></cpl><subclasses/><documentation-string>Singular value decomposition.  Singular values are in S, in descending order.  U and VT may be NIL in case they are not computed.</documentation-string></class-definition><function-definition id="lla__fun__svd-d" name="svd-d" package="lla"><lambda-list><elt>instance</elt></lambda-list></function-definition><function-definition id="lla__fun__svd-vt" name="svd-vt" package="lla"><lambda-list><elt>instance</elt></lambda-list></function-definition><function-definition id="lla__fun__svd-u" name="svd-u" package="lla"><lambda-list><elt>instance</elt></lambda-list></function-definition><function-definition id="cl-num-utils.matrix__fun__diagonal-matrix-elements" name="diagonal-matrix-elements" package="cl-num-utils.matrix"><lambda-list><elt>instance</elt></lambda-list></function-definition><function-definition id="cl-num-utils.matrix__fun__transpose" name="transpose" package="cl-num-utils.matrix"><lambda-list><elt>array</elt></lambda-list><documentation-string>Transpose.</documentation-string></function-definition></internal-symbols></package></documentation>